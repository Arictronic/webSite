// export.js - –ü–æ–ª–Ω—ã–π —É–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ —ç–∫—Å–ø–æ—Ä—Ç–∞


–¢—ã –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç —Å 30 –ª–µ—Ç–Ω–∏–º —Å—Ç–∞–∂–µ–º –≤ –≤–µ–± —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –∏ –∞—Ä—Ö–µ—Ç–µ–∫—Ç—É—Ä–µ.
–¢–µ–±–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω –∫–æ–¥ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É (btnExpPreview->buildExportPreview) –∏ (btnExpDownload->downloadFromExportModal) –∫–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏ —á—Ç–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç.
–¢–∞–∫–∂–µ Html –∫—É—Å–æ–∫ –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –ø–∞–Ω–µ–ª—å —ç–∫—Å–ø–æ—Ä—Ç–∞:
    <div
      class="backdrop"
      id="exportBackdrop"
      role="dialog"
      aria-modal="true"
      aria-labelledby="exportTitle"
      hidden
    >
      <div class="modal modal-wide">
        <header class="modal-head">
          <h2 id="exportTitle">–≠–∫—Å–ø–æ—Ä—Ç</h2>
          <button
            class="ghost"
            id="btnCloseExport"
            title="–ó–∞–∫—Ä—ã—Ç—å"
            aria-label="–ó–∞–∫—Ä—ã—Ç—å"
          >
            √ó
          </button>
        </header>

        <div class="modal-body">
          <div class="grid2">
            <div class="field">
              <label for="expPreset">–ü—Ä–µ—Å–µ—Ç</label>
              <select id="expPreset"></select>
            </div>

            <div class="field">
              <label for="expFormat">–§–æ—Ä–º–∞—Ç</label>
              <select id="expFormat">
                <option value="png">PNG</option>
                <option value="jpeg">JPEG</option>
                <option value="svg">SVG</option>
              </select>
            </div>
          </div>

          <div class="grid2" id="expRasterOptions">
            <div class="field">
              <label for="expBg">–§–æ–Ω</label>
              <select id="expBg">
                <option value="auto">–ê–≤—Ç–æ (—Ç–µ–º–∞)</option>
                <option value="transparent">–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π</option>
                <option value="white">–ë–µ–ª—ã–π</option>
              </select>
            </div>

            <div class="field" id="expJpegWrap" style="display: none">
              <label for="expQuality">–ö–∞—á–µ—Å—Ç–≤–æ JPEG</label>
              <input
                id="expQuality"
                type="range"
                min="60"
                max="100"
                step="1"
                value="92"
              />
              <div class="mini" id="expQualityVal">92</div>
            </div>
          </div>

          <div class="note" id="expHint" role="note">
            –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ (–±–µ–∑ –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è).
            –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å 1‚Äì2 —Å–µ–∫—É–Ω–¥—ã.
          </div>

          <div class="hr"></div>

          <div class="export-preview">
            <div class="export-preview-frame">
              <img id="expPreviewImg" alt="–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞" />
            </div>
          </div>
        </div>

        <footer class="modal-foot">
          <div class="left-actions">
            <button class="ghost" id="btnExpPreview" type="button">
              –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä
            </button>
          </div>
          <div class="right-actions">
            <button class="ghost" id="btnExpCancel" type="button">
              –û—Ç–º–µ–Ω–∞
            </button>
            <button class="primary" id="btnExpDownload" type="button">
              –°–∫–∞—á–∞—Ç—å
            </button>
          </div>
        </footer>
      </div>
    </div>

–ü—Ä–æ–±–ª–µ–º–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –∫–Ω–æ–ø–∫–∏ –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≤ PNG –≤–∏–¥–Ω–æ –∫–∞–∫ –ø–æ–≤–µ—Ä—Ö —Ç–∞–±–ª–∏—Ü—ã, –æ–±–ª–∞—Å—Ç–∏ –±–µ–∑ –≤—Ä–µ–º–µ–Ω–∏ –∏ –Ω–µ–¥–µ–ª–∏, –ø—Ä–æ—Å—Ç–æ –∑–∞–ª–∏—Ç —Ü–≤–µ—Ç –∑–∞–ª–∏–≤–∫–∏ –ª–æ–≥–æ—Ç–∏–ø–∞, —Å–∞–º–æ–≥–æ –ª–æ–≥–æ—Ç–∏–ø–∞ –Ω–µ—Ç—É, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–µ—Ç—É (–∑–∞–Ω—è—Ç–∏–π), –∫—Ä–æ–º–µ SVG —Ñ–∞–π–ª–∞, —Ç–∞–º –µ—Å—Ç—å –∏ –ª–æ–≥–æ—Ç–∏–ø –∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ. –ù–∞–¥–æ —Ä–µ—à–∏—Ç—å —ç—Ç—É –ø—Ä–æ–±–ª–µ–º—É, —è –Ω–µ –∑–Ω–∞—é –≤ —á–µ–º –∏–º–º–µ–Ω–Ω–æ –æ–Ω–∞, –Ω–æ —è –¥–∞–º —Ç–µ–±–µ –µ—â—ë css —Ñ–∞–π–ª, –ø—Ä–æ–≤–µ—Ä—å –≤—Å–µ –∏ –∫–æ–¥ —Ç–æ–∂–µ
–í –¥—Ä—É–≥–∏—Ö —Ä–µ–∂–∏–º–∞—Ö —Ç–æ–∂–µ –ø—Ä–æ–±–ª–µ–º–∞. –í Jpeg —Ç–æ–∂–µ —Å–∞–º–æ–µ, —Ç–æ–ª—å–∫–æ —Ü–≤–µ—Ç —Å–ø–ª–æ—à–Ω–æ–π –±–µ–∑ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏. –í SVG –µ—Å—Ç—å –Ω–µ–±–æ–ª—å—à–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –Ω–µ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –∑–∞–Ω—è—Ç–∏–π
// ===================== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò –ö–û–ù–°–¢–ê–ù–¢–´ =====================

let state = DEFAULT_STATE();
let filters = {
  day: "all",
  time: "all",
  dir: new Set(),
  q: ""
};
let filterCache = new Map();
let lastPreview = null;
let cachedMetrics = null;
let metricsTimestamp = 0;
const METRICS_CACHE_TIME = 1000;

const EXPORT_PRESETS = [
  { id: "vk_square", name: "VK –ø–æ—Å—Ç 1:1 (1080√ó1080)", w: 1080, h: 1080 },
  { id: "vk_wide", name: "VK –æ–±–ª–æ–∂–∫–∞ 1.91:1 (1200√ó630)", w: 1200, h: 630 },
  { id: "tg_16_9", name: "Telegram 16:9 (1280√ó720)", w: 1280, h: 720 },
  { id: "tg_square", name: "Telegram 1:1 (1080√ó1080)", w: 1080, h: 1080 },
  { id: "a4_portrait", name: "A4 –ø–æ—Ä—Ç—Ä–µ—Ç (2480√ó3508)", w: 2480, h: 3508 },
  { id: "a4_land", name: "A4 –∞–ª—å–±–æ–º (3508√ó2480)", w: 3508, h: 2480 },
  { id: "auto", name: "Auto (–ø–æ —Ä–∞–∑–º–µ—Ä—É —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è)", w: 0, h: 0 },
];

const THEME_PRESETS = [
  {
    id: "warm-red",
    name: "Warm Red",
    tokens: {
      bg: "#f6f7fb",
      card: "#ffffff",
      text: "#0f172a",
      muted: "#64748b",
      border: "#e2e8f0",
      gridHead: "#f8fafc",
      accent: "#ef4444",
      now: "#fff7c2",
      today: "#fff5f5",
    },
  },
  {
    id: "ocean",
    name: "Ocean Blue",
    tokens: {
      bg: "#f5fbff",
      card: "#ffffff",
      text: "#0b1220",
      muted: "#475569",
      border: "#dbeafe",
      gridHead: "#eef6ff",
      accent: "#0ea5e9",
      now: "#dbeafe",
      today: "#e0f2fe",
    },
  },
  {
    id: "emerald",
    name: "Emerald",
    tokens: {
      bg: "#f6fbf7",
      card: "#ffffff",
      text: "#0b1220",
      muted: "#475569",
      border: "#d1fae5",
      gridHead: "#ecfdf5",
      accent: "#22c55e",
      now: "#dcfce7",
      today: "#e7fbe9",
    },
  },
  {
    id: "violet",
    name: "Violet",
    tokens: {
      bg: "#f7f7ff",
      card: "#ffffff",
      text: "#0b1220",
      muted: "#475569",
      border: "#e0e7ff",
      gridHead: "#f0f1ff",
      accent: "#6366f1",
      now: "#e0e7ff",
      today: "#eef2ff",
    },
  },
  {
    id: "graphite-dark",
    name: "Graphite Dark",
    tokens: {
      bg: "#0b1220",
      card: "#0f172a",
      text: "#e5e7eb",
      muted: "#94a3b8",
      border: "#1f2a44",
      gridHead: "#0b1220",
      accent: "#f59e0b",
      now: "#3a2f00",
      today: "#2a1212",
    },
  },
];

// ===================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =====================

function DEFAULT_STATE() {
  return {
    version: 13,
    settings: {
      schedule: {
        start: "08:00",
        end: "22:00",
        slotMinutes: 60,
        slotHeight: 72,
        snapMinutes: 5,
        maxPerCell: 2,
        defaultDuration: 60,
      },
      display: {
        cellView: "timeline",
        cardMode: "namecoachroom",
        showNotes: true,
        showEmptyHint: true,
        showDayView: false,
        showTodayHighlight: true,
        dayWidthPx: 0,
        cellPadPx: 6,
      },
      font: {
        preset: "custom",
        tightness: "normal",
        titleFamily: "system",
        metaFamily: "system",
        family: "system",
        lineHeight: 1.12,
        titleSize1: 12,
        titleSize2: 10,
        metaSize1: 11,
        metaSize2: 9,
        weightTitle: 900,
        weightMeta: 600,
        sampleText: "(—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ / –†–ê–°–ü–ò–°–ê–ù–ò–ï)",
        letterSpacing: 0,
        textTransform: "none",
        titleClamp: 3,
        cardPadY: 7,
        cardRadius: 12,
      },
      theme: {
        mode: "auto",
        customTokens: deepCopy(THEME_PRESETS[0].tokens),
        alpha: { today: 60, now: 65, event: 100, shadow: 10 },
      },
      logo: {
        enabled: false,
        variant: 1,
        opacity: 12,
        recolor: false,
        color: "#0ea5e9",
        layout: "center",
        tileSize: 30,
        horizontalGap: 180,
        verticalGap: 180,
        rotation: 0,
        tileOffsetX: 0,
        tileOffsetY: 0,
        uploadedFileData: null,
      },
    },
    directions: [
      { id: "yoga", name: "–ô–æ–≥–∞", color: "#ef4444" },
      { id: "pilates", name: "–ü–∏–ª–∞—Ç–µ—Å", color: "#14b8a6" },
      { id: "crossfit", name: "–ö—Ä–æ—Å—Å—Ñ–∏—Ç", color: "#0ea5e9" },
    ],
    coaches: ["–ê–Ω–Ω–∞", "–î–º–∏—Ç—Ä–∏–π", "–ï–ª–µ–Ω–∞"],
    events: [],
  };
}

function deepCopy(o) {
  return JSON.parse(JSON.stringify(o));
}

function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

function toast(kind, title, text) {
  const toasts = document.querySelector("#toasts");
  if (!toasts) {
    console.warn("–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Ç–æ—Å—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω");
    return;
  }
  
  const el = document.createElement("div");
  el.className = "toast";
  
  const icon = document.createElement("div");
  icon.className = "icon";
  icon.textContent = kind === "OK" ? "‚úì" : kind === "WARN" ? "!" : "√ó";
  icon.style.background = 
    kind === "OK" 
      ? "var(--ok)" 
      : kind === "WARN" 
        ? "var(--warn)" 
        : "var(--danger)";
  
  const content = document.createElement("div");
  content.className = "content";
  const t = document.createElement("div");
  t.className = "title";
  t.textContent = title;
  const d = document.createElement("div");
  d.className = "text";
  d.textContent = text || "";
  content.appendChild(t);
  content.appendChild(d);
  
  const actions = document.createElement("div");
  actions.className = "actions";
  const close = document.createElement("button");
  close.className = "close";
  close.textContent = "√ó";
  close.addEventListener("click", () => el.remove());
  actions.appendChild(close);
  
  el.appendChild(icon);
  el.appendChild(content);
  el.appendChild(actions);
  
  toasts.appendChild(el);
  
  setTimeout(() => {
    if (el.isConnected) el.remove();
  }, 4500);
}

// ===================== –§–£–ù–ö–¶–ò–ò –§–ò–õ–¨–¢–†–ê–¶–ò–ò =====================

function getDir(directionId) {
  return state.directions.find(d => d.id === directionId);
}

function memoizedEventVisible(ev) {
  const hash = getFilterHash();
  
  if (!filterCache.has(ev)) {
    filterCache.set(ev, {
      cache: {},
      timestamps: {},
      keys: []
    });
  }
  
  const cacheData = filterCache.get(ev);
  
  if (cacheData.cache[hash] !== undefined) {
    cacheData.timestamps[hash] = Date.now();
    return cacheData.cache[hash];
  }
  
  const isVisible = 
    matchesDay(ev) && 
    matchesTime(ev) && 
    matchesDir(ev) && 
    matchesQuery(ev);
  
  cacheData.cache[hash] = isVisible;
  cacheData.timestamps[hash] = Date.now();
  cacheData.keys.push(hash);
  
  if (cacheData.keys.length > 5) {
    let oldestKey = cacheData.keys[0];
    let oldestTime = cacheData.timestamps[oldestKey];
    
    for (let i = 1; i < cacheData.keys.length; i++) {
      const key = cacheData.keys[i];
      if (cacheData.timestamps[key] < oldestTime) {
        oldestKey = key;
        oldestTime = cacheData.timestamps[key];
      }
    }
    
    delete cacheData.cache[oldestKey];
    delete cacheData.timestamps[oldestKey];
    cacheData.keys = cacheData.keys.filter(k => k !== oldestKey);
  }
  
  return isVisible;
}

function getFilterHash() {
  const { day, time, dir, q } = filters;
  const dirStr = Array.from(dir).sort().join(",");
  return `${day}|${time}|${dirStr}|${q}`;
}

function matchesDay(ev) {
  if (filters.day === "all") return true;
  return ev.dayIndex === filters.day;
}

function matchesTime(ev) {
  if (filters.time === "all") return true;
  
  const m = ev.startMin;
  
  if (filters.time === "morning") return m >= 360 && m < 720;
  if (filters.time === "day") return m >= 720 && m < 1080;
  if (filters.time === "evening") return m >= 1080 && m < 1380;
  
  return true;
}

function matchesDir(ev) {
  if (!filters.dir.size) return true;
  return filters.dir.has(ev.directionId);
}

function matchesQuery(ev) {
  const q = (filters.q || "").trim().toLowerCase();
  if (!q) return true;
  const dir = getDir(ev.directionId);
  const hay = `${ev.name || ""} ${ev.coach || ""} ${ev.room || ""} ${dir?.name || ""}`.toLowerCase();
  return hay.includes(q);
}

// ===================== –§–£–ù–ö–¶–ò–ò –†–ê–ë–û–¢–´ –°–û –®–†–ò–§–¢–ê–ú–ò =====================

function isGenericFamily(family) {
  const generic = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];
  return generic.includes(family.toLowerCase());
}

function matchWeight(ruleWeight, wantedWeight) {
  const rw = String(ruleWeight).toLowerCase();
  if (rw === "normal") return wantedWeight === 400;
  if (rw === "bold") return wantedWeight === 700;
  const rn = parseInt(rw, 10);
  return rn === wantedWeight;
}

function normalizeFontWeight(w) {
  const s = String(w || "").trim().toLowerCase();
  if (!s) return 400;
  if (s === "normal") return 400;
  if (s === "bold") return 700;
  const n = parseInt(s, 10);
  return Number.isFinite(n) ? n : 400;
}

function _firstFontFamily(fontFamily) {
  const first = (fontFamily || "").split(",")[0].trim();
  return first.replace(/^["']|["']$/g, "");
}

function absolutizeCssUrls(cssText, baseHref) {
  return String(cssText || "").replace(/url\(([^)]+)\)/g, (m, p1) => {
    const raw = String(p1).trim().replace(/^["']|["']$/g, "");
    if (!raw) return m;
    if (/^(data:|blob:|https?:)/i.test(raw)) return m;
    const abs = new URL(raw, baseHref).href;
    return `url("${abs}")`;
  });
}

function collectUsedFontVariantsFromDom(rootEl) {
  const set = new Set();
  if (!rootEl) return set;
  
  const walker = document.createTreeWalker(rootEl, NodeFilter.SHOW_TEXT, {
    acceptNode(node) {
      return node.nodeValue && node.nodeValue.trim()
        ? NodeFilter.FILTER_ACCEPT
        : NodeFilter.FILTER_REJECT;
    },
  });
  
  let node;
  while ((node = walker.nextNode())) {
    const el = node.parentElement;
    if (!el) continue;
    
    const cs = getComputedStyle(el);
    const fam = _firstFontFamily(cs.fontFamily);
    if (!fam || isGenericFamily(fam)) continue;
    
    const weight = normalizeFontWeight(cs.fontWeight);
    const style = (cs.fontStyle || "normal").toLowerCase();
    
    set.add(`${fam}||${weight}||${style}`);
  }
  
  return set;
}

async function ensureFontsLoaded(timeoutMs = 2500, variantsSet = null) {
  try {
    if (document.fonts) {
      if (variantsSet && variantsSet.size && document.fonts.load) {
        const loads = [];
        for (const key of variantsSet) {
          const [fam, weight, style] = key.split("||");
          loads.push(document.fonts.load(`${style} ${weight} 16px "${fam}"`));
        }
        await Promise.allSettled(loads);
      }
      
      if (document.fonts.ready) {
        await Promise.race([
          document.fonts.ready,
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error("fonts timeout")), timeoutMs),
          ),
        ]);
      }
    }
  } catch (_) {}
  
  await new Promise((r) =>
    requestAnimationFrame(() => requestAnimationFrame(r)),
  );
}

async function buildFontFaceCssForVariants(variantsSet, { embedData = false } = {}) {
  let css = "";
  if (!variantsSet || !variantsSet.size) return css;
  
  const wanted = Array.from(variantsSet).map((k) => {
    const [fam, weight, style] = k.split("||");
    return {
      fam,
      weight: parseInt(weight, 10) || 1000,
      style: (style || "normal").toLowerCase(),
    };
  });
  
  for (const sheet of Array.from(document.styleSheets)) {
    const baseHref = sheet.href || document.baseURI;
    
    let rules;
    try {
      rules = sheet.cssRules;
    } catch (_) {
      continue;
    }
    
    for (const rule of Array.from(rules)) {
      if (rule.type !== CSSRule.FONT_FACE_RULE) continue;
      
      const fam = _firstFontFamily(rule.style.getPropertyValue("font-family"));
      const style = (rule.style.getPropertyValue("font-style") || "normal").toLowerCase();
      const ruleWeight = rule.style.getPropertyValue("font-weight") || "1000";
      
      const matched = wanted.some((w) => {
        if (w.fam !== fam) return false;
        if (w.style !== style) return false;
        return matchWeight(ruleWeight, w.weight);
      });
      
      if (!matched) continue;
      
      css += absolutizeCssUrls(rule.cssText, baseHref) + "\n";
    }
  }
  
  void embedData;
  return css;
}

// ===================== –§–£–ù–ö–¶–ò–ò –†–ê–ë–û–¢–´ –° –í–†–ï–ú–ï–ù–ï–ú =====================

function getBounds() {
  const s = state.settings.schedule;
  return {
    start: parseHHMM(s.start),
    end: parseHHMM(s.end),
    step: Number(s.slotMinutes),
    h: Number(s.slotHeight),
    snap: Number(s.snapMinutes),
    max: 2,
    defDur: Number(s.defaultDuration),
  };
}

function parseHHMM(s) {
  const [h, m] = (s || "").split(":").map(Number);
  if (Number.isNaN(h) || Number.isNaN(m)) return null;
  return h * 60 + m;
}

function buildSlots() {
  const { start, end, step } = getBounds();
  const out = [];
  if (start == null || end == null || step <= 0) return out;
  for (let t = start; t < end; t += step) out.push(t);
  return out;
}

// ===================== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –≠–ö–°–ü–û–†–¢–ê =====================


async function buildExportPreview() {
  const opts = getExportOptsFromUI();
  
  toast("OK", "–≠–∫—Å–ø–æ—Ä—Ç", "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞‚Ä¶");
  
  try {
    const exportResult = await executeExport(opts);
    if (!exportResult) return;
    
    const { dataUrl } = exportResult;
    expPreviewImg.src = dataUrl;
    lastPreview = { dataUrl, ...opts };
    
    toast("OK", "–≠–∫—Å–ø–æ—Ä—Ç", "–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≥–æ—Ç–æ–≤.");
  } catch (error) {
    console.error("Export error:", error);
    toast("ERR", "–≠–∫—Å–ø–æ—Ä—Ç", error?.message || "–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞");
  }
}

async function executeExport(opts) {
  const { fmt } = opts;
  
  if (fmt === "svg") {
    return await exportToSvg(opts);
  } else {
    return await exportToCanvas(opts);
  }
}

async function prepareDomForExport({ compact = false, format = 'canvas' } = {}) {
  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –º–µ—Ç—Ä–∏–∫–∏
  const metrics = getExportMetrics(true);
  const { clone, cleanup } = makeExportClone({ compact });

  if (!clone) {
    throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∫–ª–æ–Ω —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è");
  }

  // 1. –£–¥–∞–ª—è–µ–º –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
  removeInteractiveElements(clone);

  // 2. –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∏–ª–∏ –∫ —Å–æ–±—ã—Ç–∏—è–º (–≤–∞–∂–Ω–æ: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –ø—Ä—è–º—ã–µ —Å—Ç–∏–ª–∏!)
  applyCssVariablesToEvents(clone);

  // 3. –°–∫—Ä—ã–≤–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
  const hiddenRows = hideEmptyTimeRows(clone, {
    respectFilters: false,
    keepNowRow: false
  });

  // 4. –§–∏–∫—Å–∏—Ä—É–µ–º —à–∞–ø–∫—É
  const headEls = Array.from(clone.querySelectorAll(".cell.head"));
  headEls.forEach(el => {
    el.style.position = "static";
    el.style.top = "auto";
    el.style.zIndex = "auto";
  });

  // 5. –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –ª–æ–≥–æ—Ç–∏–ø–∞ (–ø–æ–∫–∞ –±–µ–∑ —Å—Ç–∏–ª–µ–π)
  const lg = state.settings.logo;
  let logoLayer = clone.querySelector("#logoLayer");
  let logoMark = clone.querySelector("#logoMark");

  if (lg.enabled) {
    if (!logoLayer) {
      logoLayer = document.createElement('div');
      logoLayer.id = 'logoLayer';
      clone.querySelector('.schedule-wrap')?.prepend(logoLayer);
    }
    if (!logoMark) {
      logoMark = document.createElement('div');
      logoMark.id = 'logoMark';
      logoLayer.appendChild(logoMark);
    }
    // –°—Ç–∏–ª–∏ –±—É–¥—É—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ø–æ–∑–∂–µ –≤ applyLogoToExport
  }

  // 6. –î–∞–µ–º –±—Ä–∞—É–∑–µ—Ä—É –ø–µ—Ä–µ—Å—á–∏—Ç–∞—Ç—å layout
  await new Promise(r => requestAnimationFrame(r));
  await new Promise(r => setTimeout(r, 50));

  // 7. –ò–∑–º–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä—ã
  const scheduleEl = clone.querySelector('.schedule');
  let width, height;

  if (scheduleEl) {
    const rect = scheduleEl.getBoundingClientRect();
    width = Math.max(100, Math.ceil(rect.width || scheduleEl.scrollWidth || 800));
    height = Math.max(100, Math.ceil(rect.height || scheduleEl.scrollHeight || 600));

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –ù–ê –ö–û–ù–¢–ï–ô–ù–ï–† (.schedule-wrap)
    clone.style.width = `${width}px`;
    clone.style.height = `${height}px`;
    clone.style.overflow = "visible";

    // –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ —Ä–∞—Å—Ç—è–≥–∏–≤–∞–µ—Ç—Å—è –Ω–∞ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
    scheduleEl.style.width = '100%';
    scheduleEl.style.height = '100%';
    scheduleEl.style.position = 'relative'; // –î–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞
  } else {
    width = Math.max(100, Math.ceil(metrics.scheduleWidth || 800));
    height = Math.max(100, Math.ceil(metrics.scheduleHeight || 600));
    clone.style.width = `${width}px`;
    clone.style.height = `${height}px`;
  }

  // 8. –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–æ–≥–æ—Ç–∏–ø –ü–û–°–õ–ï –∏–∑–º–µ—Ä–µ–Ω–∏–π, —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—è –ø—Ä—è–º—ã–µ —Å—Ç–∏–ª–∏
  if (lg.enabled) {
    await applyLogoToExport(clone, lg, metrics, format);
  }

  return {
    clone,
    cleanup,
    metrics,
    hiddenRows,
    width,
    height
  };
}

async function exportToSvg(opts) {
  if (typeof htmlToImage === "undefined" || typeof htmlToImage.toSvg !== "function") {
    toast("WARN", "SVG", "html-to-image –Ω–µ –Ω–∞–π–¥–µ–Ω (–ø—Ä–æ–≤–µ—Ä—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ).");
    return null;
  }

  // 1. –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–Ω–¥–µ—Ä –ø–µ—Ä–µ–¥ —ç–∫—Å–ø–æ—Ä—Ç–æ–º
  await new Promise(resolve => {
    renderAll();
    setTimeout(resolve, 100); // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É
  });

  // 2. –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–π DOM
  const prepared = await prepareDomForExport({
    compact: opts.compact,
    format: 'svg'
  });

  if (!prepared) {
    toast("ERR", "SVG", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å DOM –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞");
    return null;
  }

  const { clone, cleanup, width, height } = prepared;

  try {
    // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–Ω–æ
    const scheduleEl = clone.querySelector('.schedule');
    if (!scheduleEl) {
      console.error('–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –∫–ª–æ–Ω–µ –¥–ª—è SVG —ç–∫—Å–ø–æ—Ä—Ç–∞');
      toast("ERR", "SVG", "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
      throw new Error("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
    }

    // 4. –ü–æ–≤—Ç–æ—Ä–Ω–æ –ø—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∏–ª–∏ –∫–æ –≤—Å–µ–º —Å–æ–±—ã—Ç–∏—è–º –≤ –ö–õ–û–ù–ï–ï –ø–µ—Ä–µ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π SVG
    // –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è html-to-image.toSvg
    applyCssVariablesToEventsForExport(clone);

    // 5. –°–æ–±–∏—Ä–∞–µ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ —à—Ä–∏—Ñ—Ç—ã
    const usedFonts = collectUsedFontVariantsFromDom(clone);

    // 6. –ó–∞–≥—Ä—É–∂–∞–µ–º —à—Ä–∏—Ñ—Ç—ã
    await ensureFontsLoaded(2500, usedFonts);

    // 7. –ñ–¥–µ–º –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∏
    await new Promise((r) =>
      requestAnimationFrame(() => requestAnimationFrame(r))
    );

    // 8. –°–æ–±–∏—Ä–∞–µ–º CSS –¥–ª—è –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏—è —à—Ä–∏—Ñ—Ç–æ–≤
    const fontEmbedCSS = await buildFontFaceCssForVariants(usedFonts, {
      embedData: false,
    });

    // 9. –ü–æ–ª—É—á–∞–µ–º —Ü–≤–µ—Ç —Ñ–æ–Ω–∞ –∏–∑ —Ç–µ–º—ã
    const bgColor = getThemeBgCssColor() || "#ffffff";

    console.log(`SVG —ç–∫—Å–ø–æ—Ä—Ç: —Ä–∞–∑–º–µ—Ä—ã ${width}x${height}, —Ñ–æ–Ω ${bgColor}`);

    // 10. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º SVG
    const dataUrl = await htmlToImage.toSvg(clone, {
      backgroundColor: bgColor,
      width: width,
      height: height,
      pixelRatio: 1,
      cacheBust: true,
      quality: 1.0,
      fontEmbedCSS: fontEmbedCSS,
      style: {
        // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤–∏–¥–Ω—ã
        visibility: 'visible',
        opacity: '1'
      }
    });

    toast("OK", "SVG", "SVG –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≥–æ—Ç–æ–≤.");
    return { dataUrl };
  } catch (e) {
    console.error("SVG export error:", e);
    toast("ERR", "SVG", e?.message || "–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SVG");
    throw new Error(e?.message || "–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SVG");
  } finally {
    cleanup();
  }
}

async function exportToCanvas(opts) {
  if (typeof window.html2canvas !== "function") {
    toast("WARN", "–≠–∫—Å–ø–æ—Ä—Ç", "html2canvas –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.");
    return null;
  }

  // 1. –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–Ω–¥–µ—Ä –ø–µ—Ä–µ–¥ —ç–∫—Å–ø–æ—Ä—Ç–æ–º
  await new Promise(resolve => {
    renderAll();
    setTimeout(resolve, 100); // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É
  });

  // 2. –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–Ω—ã–π DOM
  const prepared = await prepareDomForExport({
    compact: opts.compact,
    format: 'canvas'
  });

  if (!prepared) {
    toast("ERR", "–≠–∫—Å–ø–æ—Ä—Ç", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å DOM –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞");
    return null;
  }

  const { clone, cleanup, width, height } = prepared;

  try {
    // 3. –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –≤—Å–µ —Ä–µ—Å—É—Ä—Å—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã
    await waitForResources(clone, 3000);

    // 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –≤–∏–¥–Ω–æ –≤ –∫–ª–æ–Ω–µ
    const scheduleEl = clone.querySelector('.schedule');
    if (!scheduleEl) {
      console.error('–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –∫–ª–æ–Ω–µ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞');
      toast("ERR", "–≠–∫—Å–ø–æ—Ä—Ç", "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ");
      throw new Error("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –∫–ª–æ–Ω–µ");
    }

    // 5. –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –≤–∏–¥–∏–º—ã–µ —Å–æ–±—ã—Ç–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    const visibleEvents = clone.querySelectorAll('.event:not(.dim)').length;
    const allEvents = clone.querySelectorAll('.event').length;
    console.log(`–≠–∫—Å–ø–æ—Ä—Ç: ${visibleEvents}/${allEvents} —Å–æ–±—ã—Ç–∏–π –≤–∏–¥–∏–º—ã`);

    // 6. –°–æ–∑–¥–∞–µ–º –æ–ø—Ü–∏–∏ –¥–ª—è html2canvas
    const html2canvasOptions = {
      backgroundColor: opts.background,
      scale: 2,
      useCORS: true,
      allowTaint: true,
      logging: false,
      width: width,
      height: height,
      x: 0,
      y: 0,
      scrollX: 0,
      scrollY: 0,
      imageTimeout: 5000,
      removeContainer: true,
      onclone: async (clonedDoc) => { // onclone —Ç–µ–ø–µ—Ä—å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π
        // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Å—Ç–∏–ª–∏ –∫ —Å–æ–±—ã—Ç–∏—è–º –≤ –∫–ª–æ–Ω–µ html2canvas
        applyCssVariablesToEventsForExport(clonedDoc);

        // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Å—Ç–∏–ª–∏ –ª–æ–≥–æ—Ç–∏–ø–∞ –≤ –∫–ª–æ–Ω–µ html2canvas
        const lg = state.settings.logo;
        if (lg.enabled) {
          const clonedLogoLayer = clonedDoc.querySelector("#logoLayer");
          const clonedLogoMark = clonedDoc.querySelector("#logoMark");
          if (clonedLogoLayer && clonedLogoMark) {
            try {
              const metrics = getExportMetrics(); // –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –∫–ª–æ–Ω–∞
              // –ü—Ä–∏–º–µ–Ω—è–µ–º –ª–æ–≥–æ—Ç–∏–ø —Å –ø—Ä—è–º–æ–π —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π —Å—Ç–∏–ª–µ–π –≤ –∫–ª–æ–Ω–µ, –ò–°–ü–û–õ–¨–ó–£–Ø –¢–£ –ñ–ï –õ–û–ì–ò–ö–£, –ß–¢–û –ò –í applyLogoToExport
              clonedLogoLayer.style.position = 'absolute';
              clonedLogoLayer.style.top = '0';
              clonedLogoLayer.style.left = '0';
              clonedLogoLayer.style.width = '100%';
              clonedLogoLayer.style.height = '100%';
              clonedLogoLayer.style.pointerEvents = 'none';
              clonedLogoLayer.style.zIndex = '0'; // <-- –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü–æ–¥ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º
              clonedLogoLayer.style.overflow = 'hidden';
              clonedLogoLayer.style.display = 'block';
              clonedLogoLayer.style.backgroundColor = lg.bg || 'transparent';
              if (lg.url) {
                 clonedLogoLayer.style.backgroundImage = `url("${lg.url}")`;
                 clonedLogoLayer.style.backgroundRepeat = lg.repeat || 'no-repeat';
                 clonedLogoLayer.style.backgroundPosition = lg.pos || 'center';
                 clonedLogoLayer.style.backgroundSize = lg.size || 'contain';
              } else {
                 clonedLogoLayer.style.backgroundImage = 'none';
              }

              clonedLogoMark.style.position = 'absolute';
              clonedLogoMark.style.pointerEvents = 'none';
              clonedLogoMark.style.zIndex = '0'; // <-- –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü–æ–¥ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º
              clonedLogoMark.style.opacity = (lg.opacity || 12) / 100; // <-- –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü—Ä–∏–º–µ–Ω—è–µ–º opacity
              clonedLogoMark.style.display = 'block';

              const clonedSchedule = clonedDoc.querySelector('.schedule');
              if (clonedSchedule) {
                clonedSchedule.style.position = 'relative';
                clonedSchedule.style.zIndex = '1'; // –ù–∞–¥ –ª–æ–≥–æ—Ç–∏–ø–æ–º
              }

              // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ª–æ–≥–æ—Ç–∏–ø–∞, –µ—Å–ª–∏ –æ–Ω–æ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç DOM, –≤ –∫–æ—Ç–æ—Ä–æ–º –Ω–∞—Ö–æ–¥–∏—Ç—Å—è logoMark
              // –≠—Ç–æ —Å–ª–æ–∂–Ω–µ–µ, –µ—Å–ª–∏ applyCenteredLogo/applyTiledLogo –∏–∑–º–µ–Ω—è—é—Ç *DOM* logoMark.
              // –í –ø—Ä–æ—Å—Ç–µ–π—à–µ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ –æ–Ω–∏ —Ç–æ–ª—å–∫–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç —Å—Ç–∏–ª–∏ *–Ω–∞ logoMark –∏–ª–∏ –µ–≥–æ –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã*,
              // –∏ —ç—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã —É–∂–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã, —Ç–æ —Å—Ç–∏–ª–∏, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º clone.applyLogoToExport,
              // –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ –∫–ª–æ–Ω html2canvas.
              // –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ applyCenteredLogo/applyTiledLogo –≤—Å—Ç–∞–≤–ª—è—é—Ç *–Ω–æ–≤—ã–µ* —ç–ª–µ–º–µ–Ω—Ç—ã –≤–Ω—É—Ç—Ä—å logoMark,
              // —Ç–æ —ç—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–≥—É—Ç –Ω–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å—Å—è, –∏ –∏—Ö –Ω—É–∂–Ω–æ –±—É–¥–µ—Ç –≤–æ—Å—Å–æ–∑–¥–∞—Ç—å –≤ clonedLogoMark.
              // –ü—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –¥–µ–ª–∞—é—Ç applyCenteredLogo/applyTiledLogo. –ò–∑ –∫–æ–¥–∞ –≤ Pasted_Text –≤–∏–¥–Ω–æ,
              // —á—Ç–æ –æ–Ω–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Ç —Å—Ç–∏–ª–∏ –Ω–∞ logoMark –∏ –º–æ–≥—É—Ç –∏–∑–º–µ–Ω—è—Ç—å –µ–≥–æ backgroundImage/mask –∏ —Ç.–ø.
              // –≠—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ—Ç—Ä–∞–∂–µ–Ω—ã –≤ clonedLogoMark, –µ—Å–ª–∏ –æ–Ω –±—ã–ª —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤–º–µ—Å—Ç–µ —Å–æ —Å—Ç–∏–ª—è–º–∏.
              // –ù–æ –µ—Å–ª–∏ –æ–Ω–∏ –¥–æ–±–∞–≤–ª—è—é—Ç *–Ω–æ–≤—ã–µ* div/img –≤–Ω—É—Ç—Ä—å logoMark, —Ç–æ —ç—Ç–æ –Ω–µ —Å–∫–æ–ø–∏—Ä—É–µ—Ç—Å—è.
              // –í –∫–æ–¥–µ applyCenteredLogo/applyTiledLogo –∏–∑ Pasted_Text —è –≤–∏–∂—É:
              // - applyCenteredLogo: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç cssText –Ω–∞ logoMark, –≤—ã–∑—ã–≤–∞–µ—Ç applyLogoStyle
              // - applyLogoStyle: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç backgroundImage/maskImage –∏ —Ç.–ø.
              // - applyTiledLogo: —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç cssText –Ω–∞ logoMark, –≤—ã–∑—ã–≤–∞–µ—Ç applyLogoStyle
              // –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç *–≤–Ω—É—Ç—Ä–∏* logoMark (—á–µ—Ä–µ–∑ —Å—Ç–∏–ª–∏, mask, bg).
              // –≠—Ç–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è *–¥–æ–ª–∂–Ω—ã* –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å—Å—è html2canvas, –µ—Å–ª–∏ DOM-—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏ —Å—Ç–∏–ª–∏ –ª–æ–≥–æ—Ç–∏–ø–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã –≤ –º–æ–º–µ–Ω—Ç –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.
              // –ü–æ—ç—Ç–æ–º—É, –µ—Å–ª–∏ applyLogoToExport –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏–ª —Å—Ç–∏–ª–∏ –Ω–∞ logoMark –≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–º clone,
              // –∏ html2canvas –∫–æ–ø–∏—Ä—É–µ—Ç DOM, –≤–∫–ª—é—á–∞—è *–≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Å—Ç–∏–ª–∏* (style attribute), —Ç–æ clonedLogoMark
              // –¥–æ–ª–∂–µ–Ω —É–∂–µ –∏–º–µ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ (opacity, mask/bg).
              // –ù–æ! –í onclone –º—ã *–ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º* —Å—Ç–∏–ª–∏ clonedLogoMark. –≠—Ç–æ –º–æ–∂–µ—Ç *—Å–±—Ä–æ—Å–∏—Ç—å* —Å—Ç–∏–ª–∏,
              // —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ applyLogoStyle.
              // –õ—É—á—à–∏–π —Å–ø–æ—Å–æ–± - —ç—Ç–æ –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é, –∞ *–ø—Ä–æ–≤–µ—Ä–∏—Ç—å* –∏ *–¥–æ–ø–æ–ª–Ω–∏—Ç—å* —Å—Ç–∏–ª–∏,
              // –∏–ª–∏ *–æ–±–Ω–æ–≤–∏—Ç—å* —Ç–æ–ª—å–∫–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ (z-index, opacity, position).
              // –û–¥–Ω–∞–∫–æ, –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏, –º—ã –ø—Ä–æ—Å—Ç–æ *–µ—â–µ —Ä–∞–∑* –ø—Ä–∏–º–µ–Ω—è–µ–º —Ç—É –∂–µ –ª–æ–≥–∏–∫—É applyLogoToExport –∫ clonedDoc.

              // –ú—ã –ù–ï –≤—ã–∑—ã–≤–∞–µ–º applyCenteredLogo/applyTiledLogo —Å–Ω–æ–≤–∞, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω–∏ –º–æ–≥—É—Ç
              // –∏–∑–º–µ–Ω—è—Ç—å DOM-—Å—Ç—Ä—É–∫—Ç—É—Ä—É, –∫–æ—Ç–æ—Ä–æ–π –º–æ–∂–µ—Ç –Ω–µ –±—ã—Ç—å –≤ clonedDoc –≤ —Ç–æ–º –∂–µ –≤–∏–¥–µ.
              // –ú—ã –ø–æ–ª–∞–≥–∞–µ–º—Å—è –Ω–∞ —Ç–æ, —á—Ç–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞, –∏ –Ω–∞–º –Ω—É–∂–Ω–æ —Ç–æ–ª—å–∫–æ —É–±–µ–¥–∏—Ç—å—Å—è,
              // —á—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç–∏–ª–∏ (z-index, opacity) —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–∞–≤–∏–ª—å–Ω–æ.
              // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∏–ª–µ–π –≤—ã—à–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º.

            } catch (error) {
              console.warn('–û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞ –≤ onclone:', error);
            }
          }
        }
      },
    };

    // 7. –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º canvas —Å —Ç–∞–π–º–∞—É—Ç–æ–º
    const capturePromise = window.html2canvas(clone, html2canvasOptions);
    const timeoutPromise = new Promise((_, reject) =>
      setTimeout(() => reject(new Error("–¢–∞–π–º–∞—É—Ç –∑–∞—Ö–≤–∞—Ç–∞ canvas (10 —Å–µ–∫—É–Ω–¥)")), 10000)
    );

    const canvas = await Promise.race([capturePromise, timeoutPromise]);

    toast("OK", "–≠–∫—Å–ø–æ—Ä—Ç", "–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–æ—Ç–æ–≤–æ");

    let finalCanvas = canvas;

    // 8. –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–µ—Å–µ—Ç –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if (opts.preset.id !== "auto") {
      const p = opts.preset;
      const target = {
        w: p.w,
        h: p.h,
        rotate: false // –ü–æ–≤–æ—Ä–æ—Ç –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
      };
      finalCanvas = createFinalCanvas(canvas, target);
    }

    // 9. –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ dataURL —Å —É—á–µ—Ç–æ–º –∫–∞—á–µ—Å—Ç–≤–∞
    const dataUrl = finalCanvas.toDataURL(opts.imageFormat, opts.quality);
    return { dataUrl };

  } catch (e) {
    console.error("Canvas export error:", e);

    // Fallback: –ø—Ä–æ–±—É–µ–º —É–ø—Ä–æ—â–µ–Ω–Ω—ã–π –∑–∞—Ö–≤–∞—Ç
    try {
      console.log("–ü—Ä–æ–±—É–µ–º fallback capture...");
      const fallbackCanvas = await fallbackCapture(clone, opts.background);
      toast("WARN", "–≠–∫—Å–ø–æ—Ä—Ç", "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω —É–ø—Ä–æ—â—ë–Ω–Ω—ã–π —ç–∫—Å–ø–æ—Ä—Ç");

      let finalCanvas = fallbackCanvas;
      if (opts.preset.id !== "auto") {
        const p = opts.preset;
        finalCanvas = createFinalCanvas(fallbackCanvas, {
          w: p.w,
          h: p.h,
          rotate: false
        });
      }

      const dataUrl = finalCanvas.toDataURL(opts.imageFormat, opts.quality);
      return { dataUrl };
    } catch (fallbackError) {
      console.error("Fallback —Ç–∞–∫–∂–µ –Ω–µ —É–¥–∞–ª—Å—è:", fallbackError);
      toast("ERR", "–≠–∫—Å–ø–æ—Ä—Ç", e?.message || "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");
      throw new Error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è");
    }
  } finally {
    // 10. –í—Å–µ–≥–¥–∞ –æ—á–∏—â–∞–µ–º
    cleanup();
  }
}

function getExportOptsFromUI() {
  const preset = getExportPresetById(expPreset.value);
  const fmt = expFormat.value;
  const imageFormat = fmt === "jpeg" ? "image/jpeg" : "image/png";
  const quality = fmt === "jpeg"
    ? Math.min(1, Math.max(0.6, Number(expQuality.value || 92) / 100))
    : 1.0;

  const background = fmt === "svg" ? null : resolveExportBackground(expBg.value);
  const compact = state.settings.display.cellView === "compact";

  return { preset, fmt, imageFormat, quality, background, compact };
}

function makeExportClone({ compact = false } = {}) {
  const node = document.querySelector(".schedule-wrap");
  if (!node) return { clone: null, cleanup: () => {} };

  // –û–±—ë—Ä—Ç–∫–∞ –≤–Ω–µ —ç–∫—Ä–∞–Ω–∞
  const wrap = document.createElement("div");
  wrap.style.cssText = `
    position: fixed;
    left: -9999px;
    top: -9999px;
    width: max-content;
    height: max-content;
    overflow: visible;
    pointer-events: none;
    z-index: -1;
    opacity: 1;
    visibility: visible;
  `;
  wrap.setAttribute("aria-hidden", "true");
  wrap.setAttribute("data-export-clone", "true");

  // –ö–ª–æ–Ω–∏—Ä—É–µ–º —Å –≥–ª—É–±–æ–∫–∏–º –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ–º
  const clone = node.cloneNode(true);
  clone.classList.add("export-mode");
  if (compact) clone.classList.add("compact-export");

  // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ, –ù–ï —Å–µ—Ç–∫—É!
  // –£–¥–∞–ª—è–µ–º !important, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –≤–∞–∂–Ω—ã–µ —Å—Ç–∏–ª–∏ –Ω–∏–∂–µ
  clone.style.position = 'static';
  clone.style.left = 'auto';
  clone.style.top = 'auto';
  clone.style.right = 'auto';
  clone.style.bottom = 'auto';
  clone.style.transform = 'none';
  clone.style.margin = '0';
  clone.style.display = 'block'; // –í–∞–∂–Ω–æ –¥–ª—è .schedule-wrap

  // üîë –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å–µ—Ç–∫–∏ .schedule
  const scheduleEl = clone.querySelector('.schedule');
  if (scheduleEl) {
    const origSchedule = document.querySelector('.schedule');
    if (origSchedule) {
      const cs = getComputedStyle(origSchedule);
      scheduleEl.style.display = 'grid';
      scheduleEl.style.gridTemplateColumns = cs.gridTemplateColumns; // ‚Üê –ö–û–ü–ò–†–£–ï–ú –°–ï–¢–ö–£!
      scheduleEl.style.width = 'max-content';
      scheduleEl.style.minWidth = '100%';
    }

    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —ç–ª–µ–º–µ–Ω—Ç—ã
    // –í–ê–ñ–ù–û: –£—Å—Ç–∞–Ω–æ–≤–∫–∞ visibility/opacity –ø–æ—Å–ª–µ —Å–±—Ä–æ—Å–∞ display –∏–∑ clone.style
    scheduleEl.querySelectorAll('.cell, .slot, .event').forEach(el => {
      el.style.display = 'block'; // –£–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è
      el.style.visibility = 'visible';
      el.classList.remove('dim');
      el.style.opacity = '1';
    });
  }

  wrap.appendChild(clone);
  document.body.appendChild(wrap);

  return {
    clone,
    cleanup: () => {
      if (wrap.parentNode) wrap.remove();
    },
  };
}

function getExportMetrics(force = false) {
  const now = Date.now();
  if (!force && cachedMetrics && (now - metricsTimestamp) < METRICS_CACHE_TIME) {
    return cachedMetrics;
  }
  
  const scheduleWrap = document.querySelector('.schedule-wrap');
  if (!scheduleWrap) {
    cachedMetrics = {
      scheduleWidth: 800,
      scheduleHeight: 600,
      contentWidth: 700,
      contentHeight: 550,
      timeColWidth: 76,
      dayHeadHeight: 42
    };
    metricsTimestamp = now;
    return cachedMetrics;
  }
  
  // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏–π
  scheduleWrap.style.display = '';
  scheduleWrap.style.visibility = 'visible';
  
  const schedule = scheduleWrap.querySelector('.schedule');
  if (!schedule) {
    cachedMetrics = {
      scheduleWidth: scheduleWrap.offsetWidth,
      scheduleHeight: scheduleWrap.offsetHeight,
      contentWidth: scheduleWrap.offsetWidth - 76,
      contentHeight: scheduleWrap.offsetHeight - 42,
      timeColWidth: 76,
      dayHeadHeight: 42
    };
    metricsTimestamp = now;
    return cachedMetrics;
  }
  
  // –ò–∑–º–µ—Ä—è–µ–º –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Å—á–µ—Ç–∞ layout
  setTimeout(() => {}, 0);
  
  const rect = schedule.getBoundingClientRect();
  const timeCell = schedule.querySelector('.cell.time');
  const headCell = schedule.querySelector('.cell.head');
  
  cachedMetrics = {
    scheduleWidth: Math.max(100, rect.width || schedule.offsetWidth || 800),
    scheduleHeight: Math.max(100, rect.height || schedule.offsetHeight || 600),
    contentWidth: Math.max(100, (rect.width || 800) - (timeCell?.offsetWidth || 76)),
    contentHeight: Math.max(100, (rect.height || 600) - (headCell?.offsetHeight || 42)),
    timeColWidth: timeCell?.offsetWidth || 76,
    dayHeadHeight: headCell?.offsetHeight || 42
  };
  
  metricsTimestamp = now;
  return cachedMetrics;
}

function removeInteractiveElements(element) {
  const selectors = [
    ".grab",
    ".day-actions",
    "button",
    '[draggable="true"]',
    ".empty-slot",
  ];
  
  selectors.forEach((selector) => {
    element.querySelectorAll(selector).forEach((el) => {
      el.style.display = "none";
      el.style.visibility = "hidden";
      el.style.pointerEvents = "none";
    });
  });
}

function hideEmptyTimeRows(rootEl, options = {}) {
  const { respectFilters = true, keepNowRow = true } = options;
  const scheduleEl = rootEl.querySelector(".schedule");
  if (!scheduleEl) return [];
  
  if (scheduleEl.classList.contains("compact-mode")) return [];
  
  const { step } = getBounds();
  const slots = buildSlots();
  if (!slots.length || !step) return [];
  
  const allCells = Array.from(scheduleEl.children);
  if (!allCells.length) return [];
  
  const COLS = scheduleEl.querySelectorAll(".cell.head").length || 8;
  const headerCount = COLS;
  
  const events = respectFilters && typeof memoizedEventVisible === "function"
    ? state.events.filter(memoizedEventVisible)
    : state.events;
  
  const base = slots[0];
  const diff = new Array(slots.length + 1).fill(0);
  
  for (const ev of events) {
    const evStart = ev && Number(ev.startMin);
    const evEnd = evStart + Number(ev.durationMin);
    
    if (!Number.isFinite(evStart) || !Number.isFinite(evEnd) || evEnd <= evStart)
      continue;
    
    let first = Math.floor((evStart - base) / step);
    let last = Math.floor((evEnd - 1 - base) / step);
    
    if (last < 0 || first >= slots.length) continue;
    
    first = Math.max(0, first);
    last = Math.min(slots.length - 1, last);
    
    diff[first] += 1;
    diff[last + 1] -= 1;
  }
  
  const has = new Array(slots.length).fill(false);
  let run = 0;
  for (let i = 0; i < slots.length; i++) {
    run += diff[i];
    has[i] = run > 0;
  }
  
  const changed = [];
  const hideCell = (el) => {
    const prevDisplay = el.style.display;
    if (prevDisplay === "none") return;
    changed.push({ el, prevDisplay });
    el.style.display = "none";
  };
  
  for (let slotIndex = 0; slotIndex < slots.length; slotIndex++) {
    if (has[slotIndex]) continue;
    
    const rowStartIndex = headerCount + slotIndex * COLS;
    const timeCell = allCells[rowStartIndex];
    
    if (keepNowRow && timeCell && timeCell.classList.contains("now"))
      continue;
    
    for (let i = 0; i < COLS; i++) {
      const cell = allCells[rowStartIndex + i];
      if (cell) hideCell(cell);
    }
  }
  
  return changed;
}

async function applyLogoToExport(element, lg, metrics, format = 'canvas') {
  let logoLayer = element.querySelector("#logoLayer");
  let logoMark = element.querySelector("#logoMark");

  if (!logoLayer || !logoMark) {
    console.warn('–≠–ª–µ–º–µ–Ω—Ç—ã –ª–æ–≥–æ—Ç–∏–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ DOM –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞.');
    return;
  }

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –í–°–ï —Å—Ç–∏–ª–∏ –Ω–∞–ø—Ä—è–º—É—é, —á—Ç–æ–±—ã html2canvas/html-to-image –∏—Ö —É–≤–∏–¥–µ–ª
  // –õ–û–ì–û–¢–ò–ü –ü–û–î —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º (–∫–ª—é—á–µ–≤–æ–µ!)
  logoLayer.style.position = 'absolute';
  logoLayer.style.top = '0';
  logoLayer.style.left = '0';
  logoLayer.style.width = '100%';
  logoLayer.style.height = '100%';
  logoLayer.style.pointerEvents = 'none';
  logoLayer.style.zIndex = '0'; // <-- –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü–æ–¥ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º
  logoLayer.style.overflow = 'hidden';
  logoLayer.style.display = 'block';

  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–æ–Ω–æ–≤—ã–µ —Å—Ç–∏–ª–∏ –Ω–∞–ø—Ä—è–º—É—é
  logoLayer.style.backgroundColor = lg.bg || 'transparent';
  if (lg.url) {
     logoLayer.style.backgroundImage = `url("${lg.url}")`;
     logoLayer.style.backgroundRepeat = lg.repeat || 'no-repeat';
     logoLayer.style.backgroundPosition = lg.pos || 'center';
     logoLayer.style.backgroundSize = lg.size || 'contain';
  } else {
     logoLayer.style.backgroundImage = 'none';
  }

  logoMark.style.position = 'absolute';
  logoMark.style.pointerEvents = 'none';
  logoMark.style.zIndex = '0'; // <-- –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –ü–æ–¥ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º
  logoMark.style.opacity = (lg.opacity || 12) / 100;
  logoMark.style.display = 'block';

  // –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –ù–ê–î –ª–æ–≥–æ—Ç–∏–ø–æ–º
  const scheduleEl = element.querySelector('.schedule');
  if (scheduleEl) {
    scheduleEl.style.position = 'relative';
    scheduleEl.style.zIndex = '1'; // –ù–∞–¥ –ª–æ–≥–æ—Ç–∏–ø–æ–º
  }

  // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –ª–æ–≥–æ—Ç–∏–ø–∞ (—Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π, —Ç–∞–π–ª–æ–≤—ã–π –∏ —Ç.–¥.)
  try {
    const variant = getLogoVariant();
    const layout = lg.layout || "center";
    const opacity = (lg.opacity || 12) / 100;

    if (layout === "center") {
      await applyCenteredLogo(logoMark, lg, metrics, variant, opacity);
    } else if (layout === "tile" || layout === "diagonal") {
      await applyTiledLogo(logoMark, lg, metrics, variant, opacity, layout);
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞:', error);
    logoLayer.style.display = 'none';
    logoMark.style.display = 'none';
  }
}

async function applyCenteredLogo(logoMark, lg, metrics, variant, opacity) {
  const tileSize = Math.max(100, Math.min(1000, Number(lg.tileSize) || 140));
  const halfSize = tileSize / 2;
  
  const centerX = metrics.timeColWidth + metrics.contentWidth / 2;
  const centerY = metrics.dayHeadHeight + metrics.contentHeight / 2;
  
  const leftBoundary = metrics.timeColWidth;
  const rightBoundary = metrics.timeColWidth + metrics.contentWidth;
  const topBoundary = metrics.dayHeadHeight;
  const bottomBoundary = metrics.dayHeadHeight + metrics.contentHeight;
  
  let left = centerX - halfSize;
  let top = centerY - halfSize;
  let finalTileSize = tileSize;
  
  if (left < leftBoundary) left = leftBoundary;
  if (left + finalTileSize > rightBoundary) left = rightBoundary - finalTileSize;
  if (top < topBoundary) top = topBoundary;
  if (top + finalTileSize > bottomBoundary) top = bottomBoundary - finalTileSize;
  
  if (rightBoundary - leftBoundary < finalTileSize) {
    finalTileSize = rightBoundary - leftBoundary;
    left = leftBoundary;
  }
  if (bottomBoundary - topBoundary < finalTileSize) {
    finalTileSize = Math.min(finalTileSize, bottomBoundary - topBoundary);
    top = topBoundary;
  }
  
  logoMark.style.cssText = `
    position: absolute;
    pointer-events: none;
    z-index: 1;
    opacity: ${opacity};
    width: ${finalTileSize}px;
    height: ${finalTileSize}px;
    left: ${left}px;
    top: ${top}px;
    transform: rotate(${lg.rotation || 0}deg);
  `;
  
  const src = getLogoDataUrl(variant, lg.recolor ? lg.color : null, lg.opacity);
  applyLogoStyle(logoMark, src, lg.recolor && variant === 3 ? lg.color : null, opacity, false);
}

async function applyTiledLogo(logoMark, lg, metrics, variant, opacity, layout) {
  const tileSize = Math.max(20, Math.min(1000, Number(lg.tileSize) || 140));
  const horizontalGap = Number(lg.horizontalGap || 180);
  const verticalGap = Number(lg.verticalGap || 180);
  const offsetX = Number(lg.tileOffsetX || 0);
  const offsetY = Number(lg.tileOffsetY || 0);
  
  logoMark.style.cssText = `
    position: absolute;
    pointer-events: none;
    z-index: 1;
    opacity: ${opacity};
    left: ${metrics.timeColWidth}px;
    top: ${metrics.dayHeadHeight}px;
    width: ${metrics.contentWidth}px;
    height: ${metrics.contentHeight}px;
  `;
  
  const src = window.getTileSrc?.(
    variant,
    tileSize,
    horizontalGap,
    verticalGap,
    lg.rotation || 0,
    layout,
    lg.recolor ? lg.color : null,
    lg.opacity
  ) || getLogoDataUrl(variant, lg.recolor ? lg.color : null, lg.opacity);
  
  if (lg.recolor && variant === 3) {
    logoMark.style.backgroundColor = lg.color || "#0ea5e9";
    logoMark.style.webkitMaskImage = `url(${src})`;
    logoMark.style.maskImage = `url(${src})`;
    logoMark.style.webkitMaskRepeat = 'repeat';
    logoMark.style.maskRepeat = 'repeat';
    
    const patternSize = layout === "diagonal" 
      ? `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`
      : `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
    
    logoMark.style.webkitMaskSize = patternSize;
    logoMark.style.maskSize = patternSize;
    logoMark.style.webkitMaskPosition = `${offsetX}px ${offsetY}px`;
    logoMark.style.maskPosition = `${offsetX}px ${offsetY}px`;
  } else {
    logoMark.style.backgroundImage = `url(${src})`;
    logoMark.style.backgroundRepeat = 'repeat';
    
    const patternSize = layout === "diagonal"
      ? `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`
      : `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
    
    logoMark.style.backgroundSize = patternSize;
    logoMark.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
  }
}

function applyLogoToClonedDoc(logoLayer, logoMark, lg, metrics) {
  if (!logoLayer || !logoMark) return;
  
  const variant = getLogoVariant();
  const layout = lg.layout || "center";
  const opacity = (lg.opacity || 12) / 100;
  
  logoLayer.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
    overflow: hidden;
    display: block;
  `;
  
  logoMark.style.cssText = `
    position: absolute;
    pointer-events: none;
    z-index: 1;
    opacity: ${opacity};
  `;
  
  if (layout === "center") {
    const tileSize = Math.max(100, Math.min(1000, Number(lg.tileSize) || 140));
    const centerX = metrics.timeColWidth + metrics.contentWidth / 2;
    const centerY = metrics.dayHeadHeight + metrics.contentHeight / 2;
    
    logoMark.style.cssText += `
      width: ${tileSize}px;
      height: ${tileSize}px;
      left: ${centerX - tileSize / 2}px;
      top: ${centerY - tileSize / 2}px;
      transform: rotate(${lg.rotation || 0}deg);
    `;
    
    const src = getLogoDataUrl(variant, lg.recolor ? lg.color : null, lg.opacity);
    
    if (lg.recolor && variant === 3) {
      logoMark.style.backgroundColor = lg.color || "#0ea5e9";
      logoMark.style.webkitMaskImage = `url(${src})`;
      logoMark.style.maskImage = `url(${src})`;
      logoMark.style.webkitMaskRepeat = 'no-repeat';
      logoMark.style.maskRepeat = 'no-repeat';
      logoMark.style.webkitMaskPosition = 'center';
      logoMark.style.maskPosition = 'center';
      logoMark.style.webkitMaskSize = 'contain';
      logoMark.style.maskSize = 'contain';
    } else {
      logoMark.style.backgroundImage = `url(${src})`;
      logoMark.style.backgroundRepeat = 'no-repeat';
      logoMark.style.backgroundPosition = 'center';
      logoMark.style.backgroundSize = 'contain';
    }
  } else if (layout === "tile" || layout === "diagonal") {
    const tileSize = Math.max(20, Math.min(1000, Number(lg.tileSize) || 140));
    const horizontalGap = Number(lg.horizontalGap || 180);
    const verticalGap = Number(lg.verticalGap || 180);
    const offsetX = Number(lg.tileOffsetX || 0);
    const offsetY = Number(lg.tileOffsetY || 0);
    
    logoMark.style.cssText += `
      left: ${metrics.timeColWidth}px;
      top: ${metrics.dayHeadHeight}px;
      width: ${metrics.contentWidth}px;
      height: ${metrics.contentHeight}px;
    `;
    
    const src = window.getTileSrc?.(
      variant,
      tileSize,
      horizontalGap,
      verticalGap,
      lg.rotation || 0,
      layout,
      lg.recolor ? lg.color : null,
      lg.opacity
    ) || getLogoDataUrl(variant, lg.recolor ? lg.color : null, lg.opacity);
    
    if (lg.recolor && variant === 3) {
      logoMark.style.backgroundColor = lg.color || "#0ea5e9";
      logoMark.style.webkitMaskImage = `url(${src})`;
      logoMark.style.maskImage = `url(${src})`;
      logoMark.style.webkitMaskRepeat = 'repeat';
      logoMark.style.maskRepeat = 'repeat';
      
      const patternSize = layout === "diagonal"
        ? `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`
        : `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
      
      logoMark.style.webkitMaskSize = patternSize;
      logoMark.style.maskSize = patternSize;
      logoMark.style.webkitMaskPosition = `${offsetX}px ${offsetY}px`;
      logoMark.style.maskPosition = `${offsetX}px ${offsetY}px`;
    } else {
      logoMark.style.backgroundImage = `url(${src})`;
      logoMark.style.backgroundRepeat = 'repeat';
      
      const patternSize = layout === "diagonal"
        ? `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`
        : `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
      
      logoMark.style.backgroundSize = patternSize;
      logoMark.style.backgroundPosition = `${offsetX}px ${offsetY}px`;
    }
  }
  
  logoLayer.style.display = 'block';
  logoMark.style.display = 'block';
}

function getLogoVariant() {
  const variant = state.settings.logo?.variant;
  if (variant === 3 && !state.settings.logo.uploadedFileData) {
    return 1;
  }
  return clamp(Math.round(Number(variant ?? 1)), 1, 3);
}

window.getLogoDataUrl = function getLogoDataUrl(variant, recolorColor = null, opacity = 100) {
  variant = Number(variant);
  
  if (variant === 3) {
    const fileData = state.settings.logo?.uploadedFileData;
    if (fileData && fileData.startsWith("data:")) {
      if (recolorColor || opacity < 100) {
        const base64 = fileData.split(',')[1];
        let svgText = atob(base64);
        
        if (recolorColor && fileData.includes("image/svg+xml")) {
          svgText = svgText.replace(/(fill|stroke)="[^"]*"/g, `$1="${recolorColor}"`);
        }
        
        if (opacity < 100) {
          const opacityValue = opacity / 100;
          const svgStart = svgText.indexOf('<svg');
          if (svgStart !== -1) {
            const svgEnd = svgText.indexOf('>', svgStart);
            const svgTag = svgText.substring(svgStart, svgEnd + 1);
            
            if (svgTag.includes('style="')) {
              svgText = svgText.replace(/style="([^"]*)"/, `style="$1;opacity:${opacityValue}"`);
            } else {
              svgText = svgText.replace(svgTag, svgTag.replace('>', ` style="opacity:${opacityValue}">`));
            }
          }
        }
        
        return `data:image/svg+xml;base64,${btoa(svgText)}`;
      }
      return fileData;
    }
    variant = 1;
  }
  
  let svgString;
  if (variant === 1) {
    svgString = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="currentColor"/></svg>';
  } else if (variant === 2) {
    svgString = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect x="10" y="10" width="80" height="80" rx="15" fill="currentColor"/></svg>';
  } else {
    svgString = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="currentColor"/></svg>';
  }
  
  if (recolorColor && (variant === 1 || variant === 2)) {
    svgString = svgString.replace(/fill="currentColor"/g, `fill="${recolorColor}"`);
  }
  
  if (opacity < 100 && (variant === 1 || variant === 2)) {
    const opacityValue = opacity / 100;
    if (variant === 1) {
      svgString = svgString.replace('<circle ', `<circle style="opacity:${opacityValue}" `);
    } else if (variant === 2) {
      svgString = svgString.replace('<rect ', `<rect style="opacity:${opacityValue}" `);
    }
  }
  
  const base64 = btoa(unescape(encodeURIComponent(svgString)));
  return `data:image/svg+xml;base64,${base64}`;
};

function applyLogoStyle(element, src, recolorColor = null, opacity = 1, isTile = false) {
  element.style.opacity = opacity;
  
  if (recolorColor && src) {
    element.style.backgroundColor = recolorColor;
    element.style.webkitMaskImage = `url(${src})`;
    element.style.maskImage = `url(${src})`;
    element.style.webkitMaskRepeat = isTile ? 'repeat' : 'no-repeat';
    element.style.maskRepeat = isTile ? 'repeat' : 'no-repeat';
    element.style.webkitMaskPosition = 'center';
    element.style.maskPosition = 'center';
    element.style.webkitMaskSize = isTile ? 'contain' : 'contain';
    element.style.maskSize = isTile ? 'contain' : 'contain';
    element.style.backgroundImage = 'none';
  } else if (src) {
    element.style.backgroundImage = `url(${src})`;
    element.style.backgroundRepeat = isTile ? 'repeat' : 'no-repeat';
    element.style.backgroundPosition = 'center';
    element.style.backgroundSize = 'contain';
  }
}

async function waitForResources(element, timeout = 2000) {
  const startTime = Date.now();
  const resources = [];
  
  const images = element.querySelectorAll("img");
  images.forEach((img) => {
    if (!img.complete) {
      resources.push(
        new Promise((resolve) => {
          img.onload = resolve;
          img.onerror = resolve;
        })
      );
    }
  });
  
  const elementsWithBg = element.querySelectorAll('[style*="background"], [style*="mask"]');
  elementsWithBg.forEach((el) => {
    const style = getComputedStyle(el);
    const bg = style.backgroundImage;
    const mask = style.maskImage || style.webkitMaskImage;
    
    if (bg && bg !== "none" && !bg.includes("gradient")) {
      resources.push(new Promise((resolve) => {
        const img = new Image();
        img.onload = resolve;
        img.onerror = resolve;
        const urlMatch = bg.match(/url\(["']?(.*?)["']?\)/);
        if (urlMatch && urlMatch[1]) img.src = urlMatch[1];
        else resolve();
      }));
    }
    
    if (mask && mask !== "none") {
      resources.push(new Promise((resolve) => {
        const img = new Image();
        img.onload = resolve;
        img.onerror = resolve;
        const urlMatch = mask.match(/url\(["']?(.*?)["']?\)/);
        if (urlMatch && urlMatch[1]) img.src = urlMatch[1];
        else resolve();
      }));
    }
  });
  
  if (document.fonts && document.fonts.ready) {
    resources.push(document.fonts.ready);
  }
  
  try {
    await Promise.race([
      Promise.allSettled(resources),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error("–¢–∞–π–º–∞—É—Ç –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤")), timeout)
      )
    ]);
  } catch (e) {
    console.warn("–ù–µ –≤—Å–µ —Ä–µ—Å—É—Ä—Å—ã –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å:", e.message);
  }
  
  await new Promise((resolve) => requestAnimationFrame(resolve));
  await new Promise((resolve) => setTimeout(resolve, 50));
}

async function fallbackCapture(element, background = null) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã —ç–ª–µ–º–µ–Ω—Ç–∞
  const rect = element.getBoundingClientRect();
  const width = Math.max(100, rect.width || element.offsetWidth || 800);
  const height = Math.max(100, rect.height || element.offsetHeight || 600);
  
  canvas.width = width;
  canvas.height = height;
  
  // –ó–∞–ª–∏–≤–∞–µ–º —Ñ–æ–Ω
  if (background) {
    ctx.fillStyle = background;
  } else {
    ctx.fillStyle = '#ffffff';
  }
  ctx.fillRect(0, 0, width, height);
  
  // –†–∏—Å—É–µ–º –ø—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –æ—à–∏–±–∫–µ
  ctx.fillStyle = '#000000';
  ctx.font = '16px Arial';
  ctx.fillText("–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞", 20, 30);
  
  // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ —Å–æ–±—ã—Ç–∏–π
  const eventCount = element.querySelectorAll('.event').length;
  ctx.fillText(`–°–æ–±—ã—Ç–∏–π –≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏: ${eventCount}`, 20, 60);
  
  // –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É
  const now = new Date();
  ctx.fillText(`–î–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: ${now.toLocaleDateString()}`, 20, 90);
  
  return canvas;
}

function createFinalCanvas(sourceCanvas, fmt) {
  const final = document.createElement("canvas");
  final.width = fmt.w;
  final.height = fmt.h;
  
  const ctx = final.getContext("2d");
  
  const srcW = sourceCanvas.width;
  const srcH = sourceCanvas.height;
  
  const scale = Math.min(fmt.w / srcW, fmt.h / srcH);
  const dw = srcW * scale;
  const dh = srcH * scale;
  const x = (fmt.w - dw) / 2;
  const y = (fmt.h - dh) / 2;
  
  ctx.save();
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  
  // –ü—Ä–æ—Å—Ç–æ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –±–µ–∑ –ø–æ–≤–æ—Ä–æ—Ç–∞
  ctx.drawImage(sourceCanvas, x, y, dw, dh);
  
  ctx.restore();
  return final;
}

function getExportPresetById(id) {
  return EXPORT_PRESETS.find((p) => p.id === id) || EXPORT_PRESETS[0];
}

function resolveExportBackground(expBg) {
  if (expBg === "transparent") {
    return expFormat.value === "jpeg" ? "#ffffff" : null;
  }
  if (expBg === "white") return "#ffffff";
  return getThemeBgCssColor();
}

function getThemeBgCssColor() {
  const cs = getComputedStyle(document.documentElement);
  let bg = (cs.getPropertyValue("--bg") || "").trim();
  if (!bg) return "#ffffff";
  if (bg.startsWith("#")) return bg;
  return `#${bg}`;
}

async function downloadFromExportModal() {
  const opts = getExportOptsFromUI();
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –ø–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
  const needsRebuild =
    !lastPreview ||
    lastPreview.fmt !== opts.fmt ||
    lastPreview.preset?.id !== opts.preset?.id ||
    lastPreview.imageFormat !== opts.imageFormat ||
    lastPreview.quality !== opts.quality ||
    lastPreview.background !== opts.background ||
    lastPreview.compact !== opts.compact;
  
  try {
    // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ—Å—Ç—Ä–æ–∏—Ç—å –∏–ª–∏ –Ω–µ—Ç –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
    if (needsRebuild || !lastPreview?.dataUrl) {
      toast("OK", "–≠–∫—Å–ø–æ—Ä—Ç", "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–∞–π–ª–∞ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è‚Ä¶");
      const exportResult = await executeExport(opts);
      
      if (!exportResult) {
        toast("ERR", "–≠–∫—Å–ø–æ—Ä—Ç", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å —Ñ–∞–π–ª –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è");
        return;
      }
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ lastPreview
      lastPreview = { dataUrl: exportResult.dataUrl, ...opts };
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –µ—Å—Ç—å
    if (!lastPreview?.dataUrl) {
      toast("ERR", "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ", "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è");
      return;
    }
    
    // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
    const a = document.createElement("a");
    const stamp = new Date().toISOString().slice(0, 10);
    const timestamp = new Date().toISOString().slice(11, 19).replace(/:/g, '-');
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–æ—Ä–º–∞—Ç–∞
    if (opts.fmt === "svg") {
      const fileName = `schedule-${opts.preset.id}-${stamp}_${timestamp}.svg`;
      a.download = fileName;
      a.href = lastPreview.dataUrl;
      a.click();
      toast("OK", "SVG", `–§–∞–π–ª "${fileName}" —Å–∫–∞—á–∞–Ω.`);
      return;
    }
    
    // –î–ª—è —Ñ–æ—Ä–º–∞—Ç–æ–≤ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    const ext = opts.imageFormat === "image/jpeg" ? "jpg" : "png";
    const fileName = `schedule-${opts.preset.id}-${stamp}_${timestamp}.${ext}`;
    a.download = fileName;
    a.href = lastPreview.dataUrl;
    a.click();
    
    toast("OK", "–≠–∫—Å–ø–æ—Ä—Ç", `–§–∞–π–ª "${fileName}" —Å–∫–∞—á–∞–Ω.`);
    
  } catch (error) {
    console.error("Download error:", error);
    toast("ERR", "–°–∫–∞—á–∏–≤–∞–Ω–∏–µ", error?.message || "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ —Ñ–∞–π–ª–∞");
  }
}

function setupExportDownloadButton() {
  const downloadBtn = document.querySelector('#btnExpDownload');
  if (downloadBtn) {
    downloadBtn.addEventListener('click', downloadFromExportModal);
  }


function rotateCanvas90CW(sourceCanvas) {
  const out = document.createElement("canvas");
  out.width = sourceCanvas.height;
  out.height = sourceCanvas.width;

  const ctx = out.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  ctx.translate(out.width, 0);
  ctx.rotate(Math.PI / 2);
  ctx.drawImage(sourceCanvas, 0, 0);

  return out;
}}

window.downloadFromExportModal = downloadFromExportModal;
window.setupExportDownloadButton = setupExportDownloadButton;

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupExportDownloadButton);
} else {
  setupExportDownloadButton();
}

function applyCssVariablesToEvents(clone) {
  const eventEls = clone.querySelectorAll(".event");
  
  eventEls.forEach((el) => {
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–±—ã—Ç–∏–µ
    el.style.display = 'block';
    el.style.visibility = 'visible';
    el.classList.remove('dim');
    el.style.opacity = '1';
    
    // –ö–æ–ø–∏—Ä—É–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–µ —Å—Ç–∏–ª–∏ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª–∞
    const originalId = el.dataset.eid;
    if (!originalId) return;
    
    const original = document.querySelector(`.event[data-eid="${originalId}"]`);
    if (!original) return;
    
    const cs = getComputedStyle(original);
    
    // üîë –£–ë–†–ê–¢–¨ !important –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö (–ª–æ–º–∞–µ—Ç —Ç–µ–º—É!)
    const evBg = cs.getPropertyValue("--ev-bg").trim();
    const evText = cs.getPropertyValue("--ev-text").trim();
    
    if (evBg) {
      el.style.backgroundColor = evBg;
      el.style.setProperty("--ev-bg", evBg); // ‚Üê –ë–ï–ó !important
    }
    
    if (evText) {
      el.style.color = evText;
      el.style.setProperty("--ev-text", evText); // ‚Üê –ë–ï–ó !important
    }
    
    // –ö–æ–ø–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏
    const borderColor = cs.borderColor;
    if (borderColor && borderColor !== "rgba(0, 0, 0, 0)") {
      el.style.borderColor = borderColor;
      el.style.borderStyle = cs.borderStyle || "solid";
      el.style.borderWidth = cs.borderWidth || "1px";
    }
    
    const boxShadow = cs.boxShadow;
    if (boxShadow && boxShadow !== "none") {
      el.style.boxShadow = boxShadow;
    }
  });
}

function applyCssVariablesToEventsForExport(targetElement) {
  const eventEls = targetElement.querySelectorAll(".event");

  // –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ alpha.event –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
  const globalEventAlpha = state.settings.theme.alpha.event / 100; // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ 0.0 - 1.0

  eventEls.forEach((el) => {
    const originalId = el.dataset.eid;
    if (!originalId) return;

    // –ù–∞—Ö–æ–¥–∏–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ –¥–æ–∫—É–º–µ–Ω—Ç–µ
    // –í–ê–ñ–ù–û: –ü–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –ù–ï –∏–∑ computedStyle, –∞ –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞ style
    const original = document.querySelector(`.event[data-eid="${originalId}"]`);
    if (!original) return;

    // --- –ü–†–ê–í–ò–õ–¨–ù–û–ï –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π ---
    let evBg = original.style.getPropertyValue("--ev-bg").trim(); // <-- –ö–ª—é—á–µ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
    const evText = original.style.getPropertyValue("--ev-text").trim(); // <-- –¢–∞–∫–∂–µ –∏–∑ style
    // --- –ö–æ–Ω–µ—Ü –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è ---

    // --- –õ–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ evBg —Å —É—á–µ—Ç–æ–º alpha.event ---
    let finalBackgroundColor = evBg;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ evBg –ø—É—Å—Ç—ã–º (–æ–∑–Ω–∞—á–∞–µ—Ç –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π?)
    if (!evBg) {
      // –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≤ style, —Å—á–∏—Ç–∞–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º
      finalBackgroundColor = 'rgba(0, 0, 0, 0)';
    } else {
       // evBg –º–æ–∂–µ—Ç –±—ã—Ç—å #RRGGBB, rgb(r,g,b), rgba(r,g,b,a)
       // –ù—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –±–∞–∑–æ–≤—ã–π —Ü–≤–µ—Ç –∏ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∫ –Ω–µ–º—É globalEventAlpha
       const parsedColor = parseRgbaOrHex(evBg);
       if (parsedColor) {
         // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç —Å –Ω–æ–≤–æ–π –∞–ª—å—Ñ–æ–π
         // –£–º–Ω–æ–∂–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é –∞–ª—å—Ñ—É (–µ—Å–ª–∏ –±—ã–ª–∞) –Ω–∞ globalEventAlpha
         const finalAlpha = parsedColor.a !== undefined ? parsedColor.a * globalEventAlpha : globalEventAlpha;
         finalBackgroundColor = `rgba(${parsedColor.r}, ${parsedColor.g}, ${parsedColor.b}, ${finalAlpha})`;
       } else {
         // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–µ–º evBg –∫–∞–∫ –µ—Å—Ç—å.
         // –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–π —Ü–≤–µ—Ç ('red'), –∫–æ—Ç–æ—Ä—ã–π html2canvas/svg –º–æ–∂–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å.
         // –ù–æ —ç—Ç–æ –º–µ–Ω–µ–µ –Ω–∞–¥–µ–∂–Ω–æ. –õ—É—á—à–µ –ø–∞—Ä—Å–∏—Ç—å.
         console.warn(`–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ü–≤–µ—Ç —Å–æ–±—ã—Ç–∏—è: ${evBg}. –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å.`);
         // –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ evBg –±—ã–ª hex, –æ–Ω –Ω–µ –±—É–¥–µ—Ç –∏–º–µ—Ç—å –∞–ª—å—Ñ—ã. –ù—É–∂–Ω–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ rgba.
         // parseRgbaOrHex –≤—ã—à–µ –¥–æ–ª–∂–µ–Ω —Å–ø—Ä–∞–≤–∏—Ç—å—Å—è.
         // –ï—Å–ª–∏ –æ–Ω –≤–µ—Ä–Ω—É–ª null, –∑–Ω–∞—á–∏—Ç —Ñ–æ—Ä–º–∞—Ç —Å–æ–≤—Å–µ–º –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω.
         // –í —Ç–∞–∫–æ–º —Å–ª—É—á–∞–µ, fallback - –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π –∏–ª–∏ —á–µ—Ä–Ω—ã–π —Å alpha.
         finalBackgroundColor = `rgba(0, 0, 0, ${globalEventAlpha})`;
       }
    }
    // --- –ö–æ–Ω–µ—Ü –ª–æ–≥–∏–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ evBg ---

    // –ö–†–ò–¢–ò–ß–ï–°–ö–ò: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä—è–º—ã–µ —Å—Ç–∏–ª–∏
    if (finalBackgroundColor) {
      el.style.backgroundColor = finalBackgroundColor; // <-- –≠—Ç–æ –∫–ª—é—á –¥–ª—è html2canvas –∏ html-to-image
    }
    if (evText) {
      el.style.color = evText; // <-- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–∞–ø—Ä—è–º—É—é
    }

    // –£–±–∏—Ä–∞–µ–º –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ
    el.classList.remove("dim");
    el.style.opacity = "1";
  });
}

function parseRgba(colorString) {
  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è rgb(r, g, b)
  const rgbMatch = colorString.match(/^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i);
  if (rgbMatch) {
    return {
      r: parseInt(rgbMatch[1], 10),
      g: parseInt(rgbMatch[2], 10),
      b: parseInt(rgbMatch[3], 10),
      a: 1.0 // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º a=1, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤ rgb() –Ω–µ—Ç –∞–ª—å—Ñ—ã
    };
  }

  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è rgba(r, g, b, a)
  const rgbaMatch = colorString.match(/^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0|1|0?\.\d+)\s*\)$/i);
  if (rgbaMatch) {
    return {
      r: parseInt(rgbaMatch[1], 10),
      g: parseInt(rgbaMatch[2], 10),
      b: parseInt(rgbaMatch[3], 10),
      a: parseFloat(rgbaMatch[4])
    };
  }

  // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∫—É HEX, –Ω–æ –¥–ª—è CSS-–ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–±—ã—á–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è rgb/rgba
  return null;
}

function parseRgbaOrHex(colorString) {
  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è rgb(r, g, b)
  const rgbMatch = colorString.match(/^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i);
  if (rgbMatch) {
    return {
      r: parseInt(rgbMatch[1], 10),
      g: parseInt(rgbMatch[2], 10),
      b: parseInt(rgbMatch[3], 10),
      a: 1.0 // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º a=1, –ø–æ—Ç–æ–º—É —á—Ç–æ –≤ rgb() –Ω–µ—Ç –∞–ª—å—Ñ—ã
    };
  }

  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è rgba(r, g, b, a)
  const rgbaMatch = colorString.match(/^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(0|1|0?\.\d+)\s*\)$/i);
  if (rgbaMatch) {
    return {
      r: parseInt(rgbaMatch[1], 10),
      g: parseInt(rgbaMatch[2], 10),
      b: parseInt(rgbaMatch[3], 10),
      a: parseFloat(rgbaMatch[4])
    };
  }

  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è HEX (#RGB or #RRGGBB)
  const hexMatch = colorString.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/);
  if (hexMatch) {
    let hex = hexMatch[1];
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    if (hex.length === 3) {
      hex = hex.split('').map(char => char + char).join('');
    }
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    return {
      r: r,
      g: g,
      b: b,
      a: 1.0 // HEX –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∞–ª—å—Ñ—ã
    };
  }

  // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è HEXA (#RGBA or #RRGGBBAA) - –µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
  // –≠—Ç–æ –Ω–µ—Å—Ç–∞–Ω–¥–∞—Ä—Ç, –Ω–æ –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è
  // const hexaMatch = colorString.match(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/);
  // if (hexaMatch) { ... }

  return null;
}
