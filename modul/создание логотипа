function applyLogo() {
  const lg = state.settings.logo || {};
  if (!lg.enabled) {
    const layer = ensureLogoLayer();
    if (layer) layer.style.display = "none";
    return;
  }

  const layer = ensureLogoLayer();
  if (!layer) return;

  const logoMark = $("logoMark");
  if (!logoMark) return;

  const variant = getLogoVariant();
  const layout = lg.layout || "center";
  const opacityValue = (lg.opacity || 12) / 100;
  const rotation = lg.rotation || 0;
  const recolor = !!lg.recolor;
  const color = lg.color || "#0ea5e9";

  // Получаем метрики расписания
  const metrics = getScheduleMetrics();

  // Очищаем стили
  logoMark.style.cssText = "";
  layer.style.cssText = "";

  // Показываем слой
  layer.style.cssText = `
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
    overflow: hidden;
    display: block;
  `;

  // Получаем URL логотипа
  const src = getLogoDataUrl(variant, recolor ? color : null);

  if (layout === "center") {
    // РАСЧЕТ РАЗМЕРА для центрированного режима
    const tileSizePercent = clamp(Number(lg.tileSize || 30), 0, 1000);
    const tileSizePixels = calculateTileSizeInPixels(tileSizePercent, metrics, "center");
    const tileSize = Math.max(20, tileSizePixels);

    // Рассчитываем позицию в центре области контента
    const centerX = metrics.timeColWidth + metrics.contentWidth / 2;
    const centerY = metrics.dayHeadHeight + metrics.contentHeight / 2;
    const halfSize = tileSize / 2;

    // Корректируем позицию, чтобы не выходить за границы контента
    let left = centerX - halfSize;
    let top = centerY - halfSize;

    // Ограничиваем границами области контента
    const leftBoundary = metrics.timeColWidth;
    const rightBoundary = metrics.timeColWidth + metrics.contentWidth;
    const topBoundary = metrics.dayHeadHeight;
    const bottomBoundary = metrics.dayHeadHeight + metrics.contentHeight;

    if (left < leftBoundary) left = leftBoundary;
    if (left + tileSize > rightBoundary) left = rightBoundary - tileSize;
    if (top < topBoundary) top = topBoundary;
    if (top + tileSize > bottomBoundary) top = bottomBoundary - tileSize;

    // Устанавливаем размеры и позицию
    logoMark.style.cssText = `
      position: absolute;
      pointer-events: none;
      z-index: 1;
      opacity: ${opacityValue};
      width: ${tileSize}px;
      height: ${tileSize}px;
      left: ${left}px;
      top: ${top}px;
      transform: rotate(${rotation}deg);
    `;

    if (recolor && variant === 3) {
      logoMark.style.backgroundColor = color;
      logoMark.style.webkitMaskImage = `url(${src})`;
      logoMark.style.maskImage = `url(${src})`;
      logoMark.style.webkitMaskRepeat = 'no-repeat';
      logoMark.style.maskRepeat = 'no-repeat';
      logoMark.style.webkitMaskPosition = 'center';
      logoMark.style.maskPosition = 'center';
      logoMark.style.webkitMaskSize = 'contain';
      logoMark.style.maskSize = 'contain';
      logoMark.style.backgroundImage = 'none';
    } else {
      logoMark.style.backgroundImage = `url(${src})`;
      logoMark.style.backgroundRepeat = 'no-repeat';
      logoMark.style.backgroundPosition = 'center';
      logoMark.style.backgroundSize = 'contain';
    }

  } else if (layout === "tile" || layout === "diagonal") {
    // Плиточные режимы
    const tileSize = Math.max(20, Math.min(1000, Number(lg.tileSize) || 140));
    const horizontalGap = Number(lg.horizontalGap || 180);
    const verticalGap = Number(lg.verticalGap || 180);

    // Позиционируем только в области контента
    logoMark.style.cssText = `
      position: absolute;
      pointer-events: none;
      z-index: 1;
      opacity: ${opacityValue};
      left: ${metrics.timeColWidth}px;
      top: ${metrics.dayHeadHeight}px;
      width: ${metrics.contentWidth}px;
      height: ${metrics.contentHeight}px;
    `;

    // Получаем data URL для плитки
    const src = window.getTileSrc(
      variant,
      tileSize,
      horizontalGap,
      verticalGap,
      rotation,
      layout,
      recolor ? color : null,
      lg.opacity
    );

    if (recolor && variant === 3) {
      logoMark.style.backgroundColor = color;
      logoMark.style.webkitMaskImage = `url(${src})`;
      logoMark.style.maskImage = `url(${src})`;
      logoMark.style.webkitMaskRepeat = 'repeat';
      logoMark.style.maskRepeat = 'repeat';
    } else {
      logoMark.style.backgroundImage = `url(${src})`;
      logoMark.style.backgroundRepeat = 'repeat';
    }

    // Размер паттерна
    if (layout === "diagonal") {
      logoMark.style.backgroundSize = `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`;
      if (recolor && variant === 3) {
        logoMark.style.webkitMaskSize = `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`;
        logoMark.style.maskSize = `${(tileSize + horizontalGap) * 2}px ${(tileSize + verticalGap) * 2}px`;
      }
    } else {
      logoMark.style.backgroundSize = `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
      if (recolor && variant === 3) {
        logoMark.style.webkitMaskSize = `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
        logoMark.style.maskSize = `${tileSize + horizontalGap}px ${tileSize + verticalGap}px`;
      }
    }

    // Смещение
    const offsetX = Number(lg.tileOffsetX || 0);
    const offsetY = Number(lg.tileOffsetY || 0);
    logoMark.style.backgroundPosition = `${offsetX}px ${offsetY}px`;

    if (recolor && variant === 3) {
      logoMark.style.webkitMaskPosition = `${offsetX}px ${offsetY}px`;
      logoMark.style.maskPosition = `${offsetX}px ${offsetY}px`;
    }
  }

  // Принудительно показываем
  layer.style.display = 'block';
  logoMark.style.display = 'block';
}